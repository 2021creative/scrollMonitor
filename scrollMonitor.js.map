{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///scrollMonitor.js","webpack:///webpack/bootstrap 1f085360e565d06ba08f","webpack:///./index.js","webpack:///./src/constants.js","webpack:///./src/container.js","webpack:///./src/watcher.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","init","scrollMonitor","setStateFromDOM","listenToDOM","_constants","_container","_container2","isOnServer","document","body","addEventListener","Object","defineProperty","value","VISIBILITYCHANGE","ENTERVIEWPORT","FULLYENTERVIEWPORT","EXITVIEWPORT","PARTIALLYEXITVIEWPORT","LOCATIONCHANGE","STATECHANGE","eventTypes","window","isInBrowser","defaultOffsets","top","bottom","_classCallCheck","instance","Constructor","TypeError","getViewportHeight","element","innerHeight","documentElement","clientHeight","getContentHeight","Math","max","scrollHeight","offsetHeight","scrollTop","pageYOffset","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","_watcher","_watcher2","ScrollMonitorContainer","item","parentWatcher","calculateViewport","self","viewportTop","viewportBottom","viewportHeight","documentHeight","previousDocumentHeight","calculateViewportI","watchers","recalculateLocation","updateAndTriggerWatchers","updateAndTriggerWatchersI","update","triggerCallbacks","DOMListener","bind","recalculateLocations","attachEvent","destroy","removeEventListener","detachEvent","event","contentHeight","setState","newViewportTop","newViewportHeight","newContentHeight","needsRecalcuate","latestEvent","querySelector","container","offsets","watcher","push","create","ElementWatcher","containerWatcher","watchItem","triggerCallbackArray","listeners","listenerToTriggerListI","listener","callback","isOne","splice","callbacks","j","locked","wasInViewport","wasFullyInViewport","wasAboveViewport","wasBelowViewport","isInViewport","isFullyInViewport","isAboveViewport","isBelowViewport","previousTop","previousBottom","nodeName","cachedDisplay","style","display","containerOffset","boundingRect","getBoundingClientRect","height","undefined","on","Error","join","off","one","recalculateSize","index","indexOf","lock","unlock","eventHandlerFactory","type"],"mappings":"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","file":"scrollMonitor.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"scrollMonitor\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"scrollMonitor\"] = factory();\n\telse\n\t\troot[\"scrollMonitor\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"scrollMonitor\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"scrollMonitor\"] = factory();\n\telse\n\t\troot[\"scrollMonitor\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _constants = __webpack_require__(1);\n\t\n\tvar _container = __webpack_require__(2);\n\t\n\tvar _container2 = _interopRequireDefault(_container);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar scrollMonitor = new _container2.default(_constants.isOnServer ? null : document.body);\n\t\n\tfunction init() {\n\t\tscrollMonitor.setStateFromDOM(null);\n\t\tscrollMonitor.listenToDOM();\n\t}\n\tif (document.body) {\n\t\tinit();\n\t} else {\n\t\tdocument.addEventListener('DOMContentLoaded', init);\n\t}\n\t\n\tmodule.exports = scrollMonitor;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\tvar VISIBILITYCHANGE = exports.VISIBILITYCHANGE = 'visibilityChange';\n\tvar ENTERVIEWPORT = exports.ENTERVIEWPORT = 'enterViewport';\n\tvar FULLYENTERVIEWPORT = exports.FULLYENTERVIEWPORT = 'fullyEnterViewport';\n\tvar EXITVIEWPORT = exports.EXITVIEWPORT = 'exitViewport';\n\tvar PARTIALLYEXITVIEWPORT = exports.PARTIALLYEXITVIEWPORT = 'partiallyExitViewport';\n\tvar LOCATIONCHANGE = exports.LOCATIONCHANGE = 'locationChange';\n\tvar STATECHANGE = exports.STATECHANGE = 'stateChange';\n\t\n\tvar eventTypes = exports.eventTypes = [VISIBILITYCHANGE, ENTERVIEWPORT, FULLYENTERVIEWPORT, EXITVIEWPORT, PARTIALLYEXITVIEWPORT, LOCATIONCHANGE, STATECHANGE];\n\t\n\tvar isOnServer = exports.isOnServer = typeof window === 'undefined';\n\tvar isInBrowser = exports.isInBrowser = !isOnServer;\n\t\n\tvar defaultOffsets = exports.defaultOffsets = { top: 0, bottom: 0 };\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _constants = __webpack_require__(1);\n\t\n\tvar _watcher = __webpack_require__(3);\n\t\n\tvar _watcher2 = _interopRequireDefault(_watcher);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction getViewportHeight(element) {\n\t\tif (_constants.isOnServer) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (element === document.body) {\n\t\t\treturn window.innerHeight || document.documentElement.clientHeight;\n\t\t} else {\n\t\t\treturn element.clientHeight;\n\t\t}\n\t}\n\t\n\tfunction getContentHeight(element) {\n\t\tif (_constants.isOnServer) {\n\t\t\treturn 0;\n\t\t}\n\t\n\t\tif (element === document.body) {\n\t\t\t// jQuery approach\n\t\t\t// whichever is greatest\n\t\t\treturn Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.documentElement.clientHeight);\n\t\t} else {\n\t\t\treturn element.scrollHeight;\n\t\t}\n\t}\n\t\n\tfunction scrollTop(element) {\n\t\tif (_constants.isOnServer) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (element === document.body) {\n\t\t\treturn window.pageYOffset || document.documentElement && document.documentElement.scrollTop || document.body.scrollTop;\n\t\t} else {\n\t\t\treturn element.scrollTop;\n\t\t}\n\t}\n\t\n\tvar ScrollMonitorContainer = function () {\n\t\tfunction ScrollMonitorContainer(item, parentWatcher) {\n\t\t\t_classCallCheck(this, ScrollMonitorContainer);\n\t\n\t\t\tvar self = this;\n\t\n\t\t\tthis.item = item;\n\t\t\tthis.watchers = [];\n\t\t\tthis.viewportTop = null;\n\t\t\tthis.viewportBottom = null;\n\t\t\tthis.documentHeight = getContentHeight(item);\n\t\t\tthis.viewportHeight = getViewportHeight(item);\n\t\t\tthis.DOMListener = this.DOMListener.bind(this);\n\t\n\t\t\tvar previousDocumentHeight;\n\t\n\t\t\tvar calculateViewportI;\n\t\t\tfunction calculateViewport() {\n\t\t\t\tself.viewportTop = scrollTop(item);\n\t\t\t\tself.viewportBottom = self.viewportTop + self.viewportHeight;\n\t\t\t\tself.documentHeight = getContentHeight(item);\n\t\t\t\tif (self.documentHeight !== previousDocumentHeight) {\n\t\t\t\t\tcalculateViewportI = self.watchers.length;\n\t\t\t\t\twhile (calculateViewportI--) {\n\t\t\t\t\t\tself.watchers[calculateViewportI].recalculateLocation();\n\t\t\t\t\t}\n\t\t\t\t\tpreviousDocumentHeight = self.documentHeight;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tvar updateAndTriggerWatchersI;\n\t\t\tfunction updateAndTriggerWatchers() {\n\t\t\t\t// update all watchers then trigger the events so one can rely on another being up to date.\n\t\t\t\tupdateAndTriggerWatchersI = self.watchers.length;\n\t\t\t\twhile (updateAndTriggerWatchersI--) {\n\t\t\t\t\tself.watchers[updateAndTriggerWatchersI].update();\n\t\t\t\t}\n\t\n\t\t\t\tupdateAndTriggerWatchersI = self.watchers.length;\n\t\t\t\twhile (updateAndTriggerWatchersI--) {\n\t\t\t\t\tself.watchers[updateAndTriggerWatchersI].triggerCallbacks();\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tthis.update = function () {\n\t\t\t\tcalculateViewport();\n\t\t\t\tupdateAndTriggerWatchers();\n\t\t\t};\n\t\t\tthis.recalculateLocations = function () {\n\t\t\t\tthis.documentHeight = 0;\n\t\t\t\tthis.update();\n\t\t\t};\n\t\t}\n\t\n\t\t_createClass(ScrollMonitorContainer, [{\n\t\t\tkey: 'listenToDOM',\n\t\t\tvalue: function listenToDOM() {\n\t\t\t\tif (_constants.isInBrowser) {\n\t\t\t\t\tif (window.addEventListener) {\n\t\t\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\t\t\twindow.addEventListener('scroll', this.DOMListener);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.item.addEventListener('scroll', this.DOMListener);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twindow.addEventListener('resize', this.DOMListener);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Old IE support\n\t\t\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\t\t\twindow.attachEvent('onscroll', this.DOMListener);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.item.attachEvent('onscroll', this.DOMListener);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twindow.attachEvent('onresize', this.DOMListener);\n\t\t\t\t\t}\n\t\t\t\t\tthis.destroy = function () {\n\t\t\t\t\t\tif (window.addEventListener) {\n\t\t\t\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\t\t\t\twindow.removeEventListener('scroll', this.DOMListener);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.item.removeEventListener('scroll', this.DOMListener);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twindow.removeEventListener('resize', this.DOMListener);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Old IE support\n\t\t\t\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\t\t\t\twindow.detachEvent('onscroll', this.DOMListener);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.item.detachEvent('onscroll', this.DOMListener);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twindow.detachEvent('onresize', this.DOMListener);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'destroy',\n\t\t\tvalue: function destroy() {\n\t\t\t\t// noop, override for your own purposes.\n\t\t\t\t// in listenToDOM, for example.\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'DOMListener',\n\t\t\tvalue: function DOMListener(event) {\n\t\t\t\tthis.setStateFromDOM(event);\n\t\t\t\tthis.updateAndTriggerWatchers(event);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'setStateFromDOM',\n\t\t\tvalue: function setStateFromDOM(event) {\n\t\t\t\tvar viewportTop = scrollTop(this.item);\n\t\t\t\tvar viewportHeight = getViewportHeight(this.item);\n\t\t\t\tvar contentHeight = getContentHeight(this.item);\n\t\n\t\t\t\tthis.setState(viewportTop, viewportHeight, contentHeight, event);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'setState',\n\t\t\tvalue: function setState(newViewportTop, newViewportHeight, newContentHeight, event) {\n\t\t\t\tvar needsRecalcuate = newViewportHeight !== this.viewportHeight || newContentHeight !== this.contentHeight;\n\t\n\t\t\t\tthis.latestEvent = event;\n\t\t\t\tthis.viewportTop = newViewportTop;\n\t\t\t\tthis.viewportHeight = newViewportHeight;\n\t\t\t\tthis.viewportBottom = newViewportTop + newViewportHeight;\n\t\t\t\tthis.contentHeight = newContentHeight;\n\t\n\t\t\t\tif (needsRecalcuate) {\n\t\t\t\t\tvar i = this.watchers.length;\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tthis.watchers[i].recalculateLocation();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.updateAndTriggerWatchers(event);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'updateAndTriggerWatchers',\n\t\t\tvalue: function updateAndTriggerWatchers(event) {\n\t\t\t\tvar i = this.watchers.length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tthis.watchers[i].update();\n\t\t\t\t}\n\t\n\t\t\t\ti = this.watchers.length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tthis.watchers[i].triggerCallbacks(event);\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'createCustomContainer',\n\t\t\tvalue: function createCustomContainer() {\n\t\t\t\treturn new ScrollMonitorContainer();\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'createContainer',\n\t\t\tvalue: function createContainer(item) {\n\t\t\t\tif (typeof item === 'string') {\n\t\t\t\t\titem = document.querySelector(item);\n\t\t\t\t} else if (item && item.length > 0) {\n\t\t\t\t\titem = item[0];\n\t\t\t\t}\n\t\t\t\tvar container = new ScrollMonitorContainer(item, this);\n\t\t\t\tcontainer.setStateFromDOM();\n\t\t\t\tcontainer.listenToDOM();\n\t\t\t\treturn container;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'create',\n\t\t\tvalue: function create(item, offsets) {\n\t\t\t\tif (typeof item === 'string') {\n\t\t\t\t\titem = document.querySelector(item);\n\t\t\t\t} else if (item && item.length > 0) {\n\t\t\t\t\titem = item[0];\n\t\t\t\t}\n\t\t\t\tvar watcher = new _watcher2.default(this, item, offsets);\n\t\t\t\tthis.watchers.push(watcher);\n\t\t\t\treturn watcher;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'beget',\n\t\t\tvalue: function beget(item, offsets) {\n\t\t\t\treturn this.create(item, offsets);\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn ScrollMonitorContainer;\n\t}();\n\t\n\texports.default = ScrollMonitorContainer;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\texports.default = ElementWatcher;\n\t\n\tvar _constants = __webpack_require__(1);\n\t\n\tfunction ElementWatcher(containerWatcher, watchItem, offsets) {\n\t\tvar self = this;\n\t\n\t\tthis.watchItem = watchItem;\n\t\tthis.container = containerWatcher;\n\t\n\t\tif (!offsets) {\n\t\t\tthis.offsets = _constants.defaultOffsets;\n\t\t} else if (offsets === +offsets) {\n\t\t\tthis.offsets = { top: offsets, bottom: offsets };\n\t\t} else {\n\t\t\tthis.offsets = {\n\t\t\t\ttop: offsets.top || _constants.defaultOffsets.top,\n\t\t\t\tbottom: offsets.bottom || _constants.defaultOffsets.bottom\n\t\t\t};\n\t\t}\n\t\n\t\tthis.callbacks = {}; // {callback: function, isOne: true }\n\t\n\t\tfor (var i = 0, j = _constants.eventTypes.length; i < j; i++) {\n\t\t\tself.callbacks[_constants.eventTypes[i]] = [];\n\t\t}\n\t\n\t\tthis.locked = false;\n\t\n\t\tvar wasInViewport;\n\t\tvar wasFullyInViewport;\n\t\tvar wasAboveViewport;\n\t\tvar wasBelowViewport;\n\t\n\t\tvar listenerToTriggerListI;\n\t\tvar listener;\n\t\tfunction triggerCallbackArray(listeners, event) {\n\t\t\tif (listeners.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlistenerToTriggerListI = listeners.length;\n\t\t\twhile (listenerToTriggerListI--) {\n\t\t\t\tlistener = listeners[listenerToTriggerListI];\n\t\t\t\tlistener.callback.call(self, event, self);\n\t\t\t\tif (listener.isOne) {\n\t\t\t\t\tlisteners.splice(listenerToTriggerListI, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.triggerCallbacks = function triggerCallbacks(event) {\n\t\n\t\t\tif (this.isInViewport && !wasInViewport) {\n\t\t\t\ttriggerCallbackArray(this.callbacks[_constants.ENTERVIEWPORT], event);\n\t\t\t}\n\t\t\tif (this.isFullyInViewport && !wasFullyInViewport) {\n\t\t\t\ttriggerCallbackArray(this.callbacks[_constants.FULLYENTERVIEWPORT], event);\n\t\t\t}\n\t\n\t\t\tif (this.isAboveViewport !== wasAboveViewport && this.isBelowViewport !== wasBelowViewport) {\n\t\n\t\t\t\ttriggerCallbackArray(this.callbacks[_constants.VISIBILITYCHANGE], event);\n\t\n\t\t\t\t// if you skip completely past this element\n\t\t\t\tif (!wasFullyInViewport && !this.isFullyInViewport) {\n\t\t\t\t\ttriggerCallbackArray(this.callbacks[_constants.FULLYENTERVIEWPORT], event);\n\t\t\t\t\ttriggerCallbackArray(this.callbacks[_constants.PARTIALLYEXITVIEWPORT], event);\n\t\t\t\t}\n\t\t\t\tif (!wasInViewport && !this.isInViewport) {\n\t\t\t\t\ttriggerCallbackArray(this.callbacks[_constants.ENTERVIEWPORT], event);\n\t\t\t\t\ttriggerCallbackArray(this.callbacks[_constants.EXITVIEWPORT], event);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (!this.isFullyInViewport && wasFullyInViewport) {\n\t\t\t\ttriggerCallbackArray(this.callbacks[_constants.PARTIALLYEXITVIEWPORT], event);\n\t\t\t}\n\t\t\tif (!this.isInViewport && wasInViewport) {\n\t\t\t\ttriggerCallbackArray(this.callbacks[_constants.EXITVIEWPORT], event);\n\t\t\t}\n\t\t\tif (this.isInViewport !== wasInViewport) {\n\t\t\t\ttriggerCallbackArray(this.callbacks[_constants.VISIBILITYCHANGE], event);\n\t\t\t}\n\t\t\tswitch (true) {\n\t\t\t\tcase wasInViewport !== this.isInViewport:\n\t\t\t\tcase wasFullyInViewport !== this.isFullyInViewport:\n\t\t\t\tcase wasAboveViewport !== this.isAboveViewport:\n\t\t\t\tcase wasBelowViewport !== this.isBelowViewport:\n\t\t\t\t\ttriggerCallbackArray(this.callbacks[_constants.STATECHANGE], event);\n\t\t\t}\n\t\n\t\t\twasInViewport = this.isInViewport;\n\t\t\twasFullyInViewport = this.isFullyInViewport;\n\t\t\twasAboveViewport = this.isAboveViewport;\n\t\t\twasBelowViewport = this.isBelowViewport;\n\t\t};\n\t\n\t\tthis.recalculateLocation = function () {\n\t\t\tif (this.locked) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar previousTop = this.top;\n\t\t\tvar previousBottom = this.bottom;\n\t\t\tif (this.watchItem.nodeName) {\n\t\t\t\t// a dom element\n\t\t\t\tvar cachedDisplay = this.watchItem.style.display;\n\t\t\t\tif (cachedDisplay === 'none') {\n\t\t\t\t\tthis.watchItem.style.display = '';\n\t\t\t\t}\n\t\n\t\t\t\tvar containerOffset = 0;\n\t\t\t\tif (this.container.containerWatcher) {\n\t\t\t\t\tcontainerOffset = this.container.containerWatcher.top;\n\t\t\t\t}\n\t\n\t\t\t\tvar boundingRect = this.watchItem.getBoundingClientRect();\n\t\t\t\tthis.top = boundingRect.top + this.container.viewportTop - containerOffset;\n\t\t\t\tthis.bottom = boundingRect.bottom + this.container.viewportTop - containerOffset;\n\t\n\t\t\t\tif (cachedDisplay === 'none') {\n\t\t\t\t\tthis.watchItem.style.display = cachedDisplay;\n\t\t\t\t}\n\t\t\t} else if (this.watchItem === +this.watchItem) {\n\t\t\t\t// number\n\t\t\t\tif (this.watchItem > 0) {\n\t\t\t\t\tthis.top = this.bottom = this.watchItem;\n\t\t\t\t} else {\n\t\t\t\t\tthis.top = this.bottom = this.container.documentHeight - this.watchItem;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// an object with a top and bottom property\n\t\t\t\tthis.top = this.watchItem.top;\n\t\t\t\tthis.bottom = this.watchItem.bottom;\n\t\t\t}\n\t\n\t\t\tthis.top -= this.offsets.top;\n\t\t\tthis.bottom += this.offsets.bottom;\n\t\t\tthis.height = this.bottom - this.top;\n\t\n\t\t\tif ((previousTop !== undefined || previousBottom !== undefined) && (this.top !== previousTop || this.bottom !== previousBottom)) {\n\t\t\t\ttriggerCallbackArray(this.callbacks[_constants.LOCATIONCHANGE], null);\n\t\t\t}\n\t\t};\n\t\n\t\tthis.recalculateLocation();\n\t\tthis.update();\n\t\n\t\twasInViewport = this.isInViewport;\n\t\twasFullyInViewport = this.isFullyInViewport;\n\t\twasAboveViewport = this.isAboveViewport;\n\t\twasBelowViewport = this.isBelowViewport;\n\t}\n\t\n\tElementWatcher.prototype = {\n\t\ton: function on(event, callback, isOne) {\n\t\n\t\t\t// trigger the event if it applies to the element right now.\n\t\t\tswitch (true) {\n\t\t\t\tcase event === _constants.VISIBILITYCHANGE && !this.isInViewport && this.isAboveViewport:\n\t\t\t\tcase event === _constants.ENTERVIEWPORT && this.isInViewport:\n\t\t\t\tcase event === _constants.FULLYENTERVIEWPORT && this.isFullyInViewport:\n\t\t\t\tcase event === _constants.EXITVIEWPORT && this.isAboveViewport && !this.isInViewport:\n\t\t\t\tcase event === _constants.PARTIALLYEXITVIEWPORT && this.isAboveViewport:\n\t\t\t\t\tcallback.call(this, this.container.latestEvent, this);\n\t\t\t\t\tif (isOne) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (this.callbacks[event]) {\n\t\t\t\tthis.callbacks[event].push({ callback: callback, isOne: isOne || false });\n\t\t\t} else {\n\t\t\t\tthrow new Error('Tried to add a scroll monitor listener of type ' + event + '. Your options are: ' + _constants.eventTypes.join(', '));\n\t\t\t}\n\t\t},\n\t\toff: function off(event, callback) {\n\t\t\tif (this.callbacks[event]) {\n\t\t\t\tfor (var i = 0, item; item = this.callbacks[event][i]; i++) {\n\t\t\t\t\tif (item.callback === callback) {\n\t\t\t\t\t\tthis.callbacks[event].splice(i, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error('Tried to remove a scroll monitor listener of type ' + event + '. Your options are: ' + _constants.eventTypes.join(', '));\n\t\t\t}\n\t\t},\n\t\tone: function one(event, callback) {\n\t\t\tthis.on(event, callback, true);\n\t\t},\n\t\trecalculateSize: function recalculateSize() {\n\t\t\tthis.height = this.watchItem.offsetHeight + this.offsets.top + this.offsets.bottom;\n\t\t\tthis.bottom = this.top + this.height;\n\t\t},\n\t\tupdate: function update() {\n\t\t\tthis.isAboveViewport = this.top < this.container.viewportTop;\n\t\t\tthis.isBelowViewport = this.bottom > this.container.viewportBottom;\n\t\n\t\t\tthis.isInViewport = this.top < this.container.viewportBottom && this.bottom > this.container.viewportTop;\n\t\t\tthis.isFullyInViewport = this.top >= this.container.viewportTop && this.bottom <= this.container.viewportBottom || this.isAboveViewport && this.isBelowViewport;\n\t\t},\n\t\tdestroy: function destroy() {\n\t\t\tvar index = this.container.watchers.indexOf(this),\n\t\t\t    self = this;\n\t\t\tthis.container.watchers.splice(index, 1);\n\t\t\tfor (var i = 0, j = _constants.eventTypes.length; i < j; i++) {\n\t\t\t\tself.callbacks[_constants.eventTypes[i]].length = 0;\n\t\t\t}\n\t\t},\n\t\t// prevent recalculating the element location\n\t\tlock: function lock() {\n\t\t\tthis.locked = true;\n\t\t},\n\t\tunlock: function unlock() {\n\t\t\tthis.locked = false;\n\t\t}\n\t};\n\t\n\tvar eventHandlerFactory = function eventHandlerFactory(type) {\n\t\treturn function (callback, isOne) {\n\t\t\tthis.on.call(this, type, callback, isOne);\n\t\t};\n\t};\n\t\n\tfor (var i = 0, j = _constants.eventTypes.length; i < j; i++) {\n\t\tvar type = _constants.eventTypes[i];\n\t\tElementWatcher.prototype[type] = eventHandlerFactory(type);\n\t}\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// scrollMonitor.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 1f085360e565d06ba08f","import { isOnServer } from './src/constants';\n\nimport ScrollMonitorContainer from './src/container';\n\nvar scrollMonitor = new ScrollMonitorContainer(isOnServer ? null : document.body);\n\nfunction init () {\n\tscrollMonitor.setStateFromDOM(null);\n\tscrollMonitor.listenToDOM();\n}\nif (document.body) {\n\tinit();\n} else {\n\tdocument.addEventListener('DOMContentLoaded', init);\n}\n\nmodule.exports = scrollMonitor;\n\n\n\n// WEBPACK FOOTER //\n// ./index.js","export const VISIBILITYCHANGE = 'visibilityChange';\nexport const ENTERVIEWPORT = 'enterViewport';\nexport const FULLYENTERVIEWPORT = 'fullyEnterViewport';\nexport const EXITVIEWPORT = 'exitViewport';\nexport const PARTIALLYEXITVIEWPORT = 'partiallyExitViewport';\nexport const LOCATIONCHANGE = 'locationChange';\nexport const STATECHANGE = 'stateChange';\n\nexport const eventTypes = [\n\tVISIBILITYCHANGE,\n\tENTERVIEWPORT,\n\tFULLYENTERVIEWPORT,\n\tEXITVIEWPORT,\n\tPARTIALLYEXITVIEWPORT,\n\tLOCATIONCHANGE,\n\tSTATECHANGE\n];\n\nexport const isOnServer = (typeof window === 'undefined');\nexport const isInBrowser = !isOnServer;\n\nexport const defaultOffsets = {top: 0, bottom: 0};\n\n\n\n// WEBPACK FOOTER //\n// ./src/constants.js","import { isOnServer, isInBrowser } from './constants';\nimport Watcher from './watcher';\n\nfunction getViewportHeight (element) {\n\tif (isOnServer) {\n\t\treturn 0;\n\t}\n\tif (element === document.body) {\n\t\treturn window.innerHeight || document.documentElement.clientHeight;\n\t} else {\n\t\treturn element.clientHeight;\n\t}\n}\n\nfunction getContentHeight (element) {\n\tif (isOnServer) {\n\t\treturn 0;\n\t}\n\n\tif (element === document.body) {\n\t\t// jQuery approach\n\t\t// whichever is greatest\n\t\treturn Math.max(\n\t\t\tdocument.body.scrollHeight, document.documentElement.scrollHeight,\n\t\t\tdocument.body.offsetHeight, document.documentElement.offsetHeight,\n\t\t\tdocument.documentElement.clientHeight\n\t\t);\n\t} else {\n\t\treturn element.scrollHeight;\n\t}\n}\n\nfunction scrollTop (element) {\n\tif (isOnServer) {\n\t\treturn 0;\n\t}\n\tif (element === document.body) {\n\t\treturn window.pageYOffset ||\n\t\t\t(document.documentElement && document.documentElement.scrollTop) ||\n\t\t\tdocument.body.scrollTop;\n\t} else {\n\t\treturn element.scrollTop;\n\t}\n}\n\n\nclass ScrollMonitorContainer {\n\tconstructor (item, parentWatcher) {\n\t\tvar self = this;\n\n\t\tthis.item = item;\n\t\tthis.watchers = [];\n\t\tthis.viewportTop = null;\n\t\tthis.viewportBottom = null;\n\t\tthis.documentHeight = getContentHeight(item);\n\t\tthis.viewportHeight = getViewportHeight(item);\n\t\tthis.DOMListener = this.DOMListener.bind(this);\n\n\t\tvar previousDocumentHeight;\n\n\t\tvar calculateViewportI;\n\t\tfunction calculateViewport() {\n\t\t\tself.viewportTop = scrollTop(item);\n\t\t\tself.viewportBottom = self.viewportTop + self.viewportHeight;\n\t\t\tself.documentHeight = getContentHeight(item);\n\t\t\tif (self.documentHeight !== previousDocumentHeight) {\n\t\t\t\tcalculateViewportI = self.watchers.length;\n\t\t\t\twhile( calculateViewportI-- ) {\n\t\t\t\t\tself.watchers[calculateViewportI].recalculateLocation();\n\t\t\t\t}\n\t\t\t\tpreviousDocumentHeight = self.documentHeight;\n\t\t\t}\n\t\t}\n\n\t\tvar updateAndTriggerWatchersI;\n\t\tfunction updateAndTriggerWatchers() {\n\t\t\t// update all watchers then trigger the events so one can rely on another being up to date.\n\t\t\tupdateAndTriggerWatchersI = self.watchers.length;\n\t\t\twhile( updateAndTriggerWatchersI-- ) {\n\t\t\t\tself.watchers[updateAndTriggerWatchersI].update();\n\t\t\t}\n\n\t\t\tupdateAndTriggerWatchersI = self.watchers.length;\n\t\t\twhile( updateAndTriggerWatchersI-- ) {\n\t\t\t\tself.watchers[updateAndTriggerWatchersI].triggerCallbacks();\n\t\t\t}\n\n\t\t}\n\n\t\tthis.update = function() {\n\t\t\tcalculateViewport();\n\t\t\tupdateAndTriggerWatchers();\n\t\t};\n\t\tthis.recalculateLocations = function() {\n\t\t\tthis.documentHeight = 0;\n\t\t\tthis.update();\n\t\t};\n\n\t}\n\n\tlistenToDOM () {\n\t\tif (isInBrowser) {\n\t\t\tif (window.addEventListener) {\n\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\twindow.addEventListener('scroll', this.DOMListener);\n\t\t\t\t} else {\n\t\t\t\t\tthis.item.addEventListener('scroll', this.DOMListener);\n\t\t\t\t}\n\t\t\t\twindow.addEventListener('resize', this.DOMListener);\n\t\t\t} else {\n\t\t\t\t// Old IE support\n\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\twindow.attachEvent('onscroll', this.DOMListener);\n\t\t\t\t} else {\n\t\t\t\t\tthis.item.attachEvent('onscroll', this.DOMListener);\n\t\t\t\t}\n\t\t\t\twindow.attachEvent('onresize', this.DOMListener);\n\t\t\t}\n\t\t\tthis.destroy = function () {\n\t\t\t\tif (window.addEventListener) {\n\t\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\t\twindow.removeEventListener('scroll', this.DOMListener);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.item.removeEventListener('scroll', this.DOMListener);\n\t\t\t\t\t}\n\t\t\t\t\twindow.removeEventListener('resize', this.DOMListener);\n\t\t\t\t} else {\n\t\t\t\t\t// Old IE support\n\t\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\t\twindow.detachEvent('onscroll', this.DOMListener);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.item.detachEvent('onscroll', this.DOMListener);\n\t\t\t\t\t}\n\t\t\t\t\twindow.detachEvent('onresize', this.DOMListener);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\tdestroy () {\n\t\t// noop, override for your own purposes.\n\t\t// in listenToDOM, for example.\n\t}\n\n\tDOMListener (event) {\n\t\tthis.setStateFromDOM(event);\n\t\tthis.updateAndTriggerWatchers(event);\n\t}\n\n\tsetStateFromDOM (event) {\n\t\tvar viewportTop = scrollTop(this.item);\n\t\tvar viewportHeight = getViewportHeight(this.item);\n\t\tvar contentHeight = getContentHeight(this.item);\n\n\t\tthis.setState(viewportTop, viewportHeight, contentHeight, event);\n\t}\n\n\tsetState (newViewportTop, newViewportHeight, newContentHeight, event) {\n\t\tvar needsRecalcuate = (newViewportHeight !== this.viewportHeight || newContentHeight !== this.contentHeight);\n\n\t\tthis.latestEvent = event;\n\t\tthis.viewportTop = newViewportTop;\n\t\tthis.viewportHeight = newViewportHeight;\n\t\tthis.viewportBottom = newViewportTop + newViewportHeight;\n\t\tthis.contentHeight = newContentHeight;\n\n\t\tif (needsRecalcuate) {\n\t\t\tlet i = this.watchers.length;\n\t\t\twhile (i--) {\n\t\t\t\tthis.watchers[i].recalculateLocation();\n\t\t\t}\n\t\t}\n\t\tthis.updateAndTriggerWatchers(event);\n\t}\n\n\tupdateAndTriggerWatchers (event) {\n\t\tlet i = this.watchers.length;\n\t\twhile (i--) {\n\t\t\tthis.watchers[i].update();\n\t\t}\n\n\t\ti = this.watchers.length;\n\t\twhile (i--) {\n\t\t\tthis.watchers[i].triggerCallbacks(event);\n\t\t}\n\t}\n\n\tcreateCustomContainer () {\n\t\treturn new ScrollMonitorContainer();\n\t}\n\n\tcreateContainer (item) {\n\t\tif (typeof item === 'string') {\n\t\t\titem = document.querySelector(item);\n\t\t} else if (item && item.length > 0) {\n\t\t\titem = item[0];\n\t\t}\n\t\tvar container = new ScrollMonitorContainer(item, this);\n\t\tcontainer.setStateFromDOM();\n\t\tcontainer.listenToDOM();\n\t\treturn container;\n\t}\n\n\tcreate (item, offsets) {\n\t\tif (typeof item === 'string') {\n\t\t\titem = document.querySelector(item);\n\t\t} else if (item && item.length > 0) {\n\t\t\titem = item[0];\n\t\t}\n\t\tvar watcher = new Watcher(this, item, offsets);\n\t\tthis.watchers.push(watcher);\n\t\treturn watcher;\n\t}\n\n\tbeget (item, offsets) {\n\t\treturn this.create(item, offsets);\n\t}\n}\n\nexport default ScrollMonitorContainer;\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/container.js","import {\n\tVISIBILITYCHANGE,\n\tENTERVIEWPORT,\n\tFULLYENTERVIEWPORT,\n\tEXITVIEWPORT,\n\tPARTIALLYEXITVIEWPORT,\n\tLOCATIONCHANGE,\n\tSTATECHANGE,\n\teventTypes,\n\tdefaultOffsets\n} from './constants';\n\nexport default function ElementWatcher (containerWatcher, watchItem, offsets) {\n\tvar self = this;\n\n\tthis.watchItem = watchItem;\n\tthis.container = containerWatcher;\n\n\tif (!offsets) {\n\t\tthis.offsets = defaultOffsets;\n\t} else if (offsets === +offsets) {\n\t\tthis.offsets = {top: offsets, bottom: offsets};\n\t} else {\n\t\tthis.offsets = {\n\t\t\ttop: offsets.top || defaultOffsets.top,\n\t\t\tbottom: offsets.bottom || defaultOffsets.bottom\n\t\t};\n\t}\n\n\tthis.callbacks = {}; // {callback: function, isOne: true }\n\n\tfor (var i = 0, j = eventTypes.length; i < j; i++) {\n\t\tself.callbacks[eventTypes[i]] = [];\n\t}\n\n\tthis.locked = false;\n\n\tvar wasInViewport;\n\tvar wasFullyInViewport;\n\tvar wasAboveViewport;\n\tvar wasBelowViewport;\n\n\tvar listenerToTriggerListI;\n\tvar listener;\n\tfunction triggerCallbackArray (listeners, event) {\n\t\tif (listeners.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tlistenerToTriggerListI = listeners.length;\n\t\twhile (listenerToTriggerListI--) {\n\t\t\tlistener = listeners[listenerToTriggerListI];\n\t\t\tlistener.callback.call(self, event, self);\n\t\t\tif (listener.isOne) {\n\t\t\t\tlisteners.splice(listenerToTriggerListI, 1);\n\t\t\t}\n\t\t}\n\t}\n\tthis.triggerCallbacks = function triggerCallbacks (event) {\n\n\t\tif (this.isInViewport && !wasInViewport) {\n\t\t\ttriggerCallbackArray( this.callbacks[ENTERVIEWPORT], event );\n\t\t}\n\t\tif (this.isFullyInViewport && !wasFullyInViewport) {\n\t\t\ttriggerCallbackArray( this.callbacks[FULLYENTERVIEWPORT], event );\n\t\t}\n\n\n\t\tif (this.isAboveViewport !== wasAboveViewport &&\n\t\t\tthis.isBelowViewport !== wasBelowViewport) {\n\n\t\t\ttriggerCallbackArray( this.callbacks[VISIBILITYCHANGE], event );\n\n\t\t\t// if you skip completely past this element\n\t\t\tif (!wasFullyInViewport && !this.isFullyInViewport) {\n\t\t\t\ttriggerCallbackArray( this.callbacks[FULLYENTERVIEWPORT], event );\n\t\t\t\ttriggerCallbackArray( this.callbacks[PARTIALLYEXITVIEWPORT], event );\n\t\t\t}\n\t\t\tif (!wasInViewport && !this.isInViewport) {\n\t\t\t\ttriggerCallbackArray( this.callbacks[ENTERVIEWPORT], event );\n\t\t\t\ttriggerCallbackArray( this.callbacks[EXITVIEWPORT], event );\n\t\t\t}\n\t\t}\n\n\t\tif (!this.isFullyInViewport && wasFullyInViewport) {\n\t\t\ttriggerCallbackArray( this.callbacks[PARTIALLYEXITVIEWPORT], event );\n\t\t}\n\t\tif (!this.isInViewport && wasInViewport) {\n\t\t\ttriggerCallbackArray( this.callbacks[EXITVIEWPORT], event );\n\t\t}\n\t\tif (this.isInViewport !== wasInViewport) {\n\t\t\ttriggerCallbackArray( this.callbacks[VISIBILITYCHANGE], event );\n\t\t}\n\t\tswitch( true ) {\n\t\t\tcase wasInViewport !== this.isInViewport:\n\t\t\tcase wasFullyInViewport !== this.isFullyInViewport:\n\t\t\tcase wasAboveViewport !== this.isAboveViewport:\n\t\t\tcase wasBelowViewport !== this.isBelowViewport:\n\t\t\t\ttriggerCallbackArray( this.callbacks[STATECHANGE], event );\n\t\t}\n\n\t\twasInViewport = this.isInViewport;\n\t\twasFullyInViewport = this.isFullyInViewport;\n\t\twasAboveViewport = this.isAboveViewport;\n\t\twasBelowViewport = this.isBelowViewport;\n\n\t};\n\n\tthis.recalculateLocation = function () {\n\t\tif (this.locked) {\n\t\t\treturn;\n\t\t}\n\t\tvar previousTop = this.top;\n\t\tvar previousBottom = this.bottom;\n\t\tif (this.watchItem.nodeName) { // a dom element\n\t\t\tvar cachedDisplay = this.watchItem.style.display;\n\t\t\tif (cachedDisplay === 'none') {\n\t\t\t\tthis.watchItem.style.display = '';\n\t\t\t}\n\n\t\t\tvar containerOffset = 0;\n\t\t\tif (this.container.containerWatcher) {\n\t\t\t\tcontainerOffset = this.container.containerWatcher.top;\n\t\t\t}\n\n\t\t\tvar boundingRect = this.watchItem.getBoundingClientRect();\n\t\t\tthis.top = boundingRect.top + this.container.viewportTop - containerOffset;\n\t\t\tthis.bottom = boundingRect.bottom + this.container.viewportTop - containerOffset;\n\n\t\t\tif (cachedDisplay === 'none') {\n\t\t\t\tthis.watchItem.style.display = cachedDisplay;\n\t\t\t}\n\n\t\t} else if (this.watchItem === +this.watchItem) { // number\n\t\t\tif (this.watchItem > 0) {\n\t\t\t\tthis.top = this.bottom = this.watchItem;\n\t\t\t} else {\n\t\t\t\tthis.top = this.bottom = this.container.documentHeight - this.watchItem;\n\t\t\t}\n\n\t\t} else { // an object with a top and bottom property\n\t\t\tthis.top = this.watchItem.top;\n\t\t\tthis.bottom = this.watchItem.bottom;\n\t\t}\n\n\t\tthis.top -= this.offsets.top;\n\t\tthis.bottom += this.offsets.bottom;\n\t\tthis.height = this.bottom - this.top;\n\n\t\tif ( (previousTop !== undefined || previousBottom !== undefined) && (this.top !== previousTop || this.bottom !== previousBottom) ) {\n\t\t\ttriggerCallbackArray( this.callbacks[LOCATIONCHANGE], null );\n\t\t}\n\t};\n\n\tthis.recalculateLocation();\n\tthis.update();\n\n\twasInViewport = this.isInViewport;\n\twasFullyInViewport = this.isFullyInViewport;\n\twasAboveViewport = this.isAboveViewport;\n\twasBelowViewport = this.isBelowViewport;\n}\n\nElementWatcher.prototype = {\n\ton: function (event, callback, isOne) {\n\n\t\t// trigger the event if it applies to the element right now.\n\t\tswitch( true ) {\n\t\t\tcase event === VISIBILITYCHANGE && !this.isInViewport && this.isAboveViewport:\n\t\t\tcase event === ENTERVIEWPORT && this.isInViewport:\n\t\t\tcase event === FULLYENTERVIEWPORT && this.isFullyInViewport:\n\t\t\tcase event === EXITVIEWPORT && this.isAboveViewport && !this.isInViewport:\n\t\t\tcase event === PARTIALLYEXITVIEWPORT && this.isAboveViewport:\n\t\t\t\tcallback.call(this, this.container.latestEvent, this);\n\t\t\t\tif (isOne) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t}\n\n\t\tif (this.callbacks[event]) {\n\t\t\tthis.callbacks[event].push({callback: callback, isOne: isOne||false});\n\t\t} else {\n\t\t\tthrow new Error('Tried to add a scroll monitor listener of type '+event+'. Your options are: '+eventTypes.join(', '));\n\t\t}\n\t},\n\toff: function( event, callback ) {\n\t\tif (this.callbacks[event]) {\n\t\t\tfor (var i = 0, item; item = this.callbacks[event][i]; i++) {\n\t\t\t\tif (item.callback === callback) {\n\t\t\t\t\tthis.callbacks[event].splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error('Tried to remove a scroll monitor listener of type '+event+'. Your options are: '+eventTypes.join(', '));\n\t\t}\n\t},\n\tone: function( event, callback ) {\n\t\tthis.on( event, callback, true);\n\t},\n\trecalculateSize: function() {\n\t\tthis.height = this.watchItem.offsetHeight + this.offsets.top + this.offsets.bottom;\n\t\tthis.bottom = this.top + this.height;\n\t},\n\tupdate: function() {\n\t\tthis.isAboveViewport = this.top < this.container.viewportTop;\n\t\tthis.isBelowViewport = this.bottom > this.container.viewportBottom;\n\n\t\tthis.isInViewport = (this.top < this.container.viewportBottom && this.bottom > this.container.viewportTop);\n\t\tthis.isFullyInViewport = (this.top >= this.container.viewportTop && this.bottom <= this.container.viewportBottom) || (this.isAboveViewport && this.isBelowViewport);\n\n\t},\n\tdestroy: function() {\n\t\tvar index = this.container.watchers.indexOf(this),\n\t\t\tself  = this;\n\t\tthis.container.watchers.splice(index, 1);\n\t\tfor (var i = 0, j = eventTypes.length; i < j; i++) {\n\t\t\tself.callbacks[eventTypes[i]].length = 0;\n\t\t}\n\t},\n\t// prevent recalculating the element location\n\tlock: function() {\n\t\tthis.locked = true;\n\t},\n\tunlock: function() {\n\t\tthis.locked = false;\n\t}\n};\n\nvar eventHandlerFactory = function (type) {\n\treturn function( callback, isOne ) {\n\t\tthis.on.call(this, type, callback, isOne);\n\t};\n};\n\nfor (var i = 0, j = eventTypes.length; i < j; i++) {\n\tvar type =  eventTypes[i];\n\tElementWatcher.prototype[type] = eventHandlerFactory(type);\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/watcher.js"],"sourceRoot":""}