{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///scrollMonitor.js","webpack:///webpack/bootstrap f4ddac080de9d0b47b84","webpack:///./index.js","webpack:///./src/constants.js","webpack:///./src/container.js","webpack:///./src/watcher.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_constants","_container","_container2","scrollMonitor","isInBrowser","document","body","setStateFromDOM","listenToDOM","window","Object","defineProperty","value","VISIBILITYCHANGE","ENTERVIEWPORT","FULLYENTERVIEWPORT","EXITVIEWPORT","PARTIALLYEXITVIEWPORT","LOCATIONCHANGE","STATECHANGE","isOnServer","eventTypes","defaultOffsets","top","bottom","_classCallCheck","instance","Constructor","TypeError","getViewportHeight","element","innerHeight","documentElement","clientHeight","getContentHeight","Math","max","scrollHeight","offsetHeight","scrollTop","pageYOffset","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","_watcher","_watcher2","ScrollMonitorContainer","item","parentWatcher","calculateViewport","self","viewportTop","viewportBottom","viewportHeight","documentHeight","previousDocumentHeight","calculateViewportI","watchers","recalculateLocation","updateAndTriggerWatchers","updateAndTriggerWatchersI","update","triggerCallbacks","DOMListener","bind","containerWatcher","create","recalculateLocations","addEventListener","attachEvent","destroy","removeEventListener","detachEvent","event","contentHeight","setState","newViewportTop","newViewportHeight","newContentHeight","needsRecalcuate","latestEvent","querySelector","container","offsets","watcher","push","ElementWatcher","watchItem","triggerCallbackArray","listeners","listenerToTriggerListI","listener","callback","isOne","splice","callbacks","j","locked","wasInViewport","wasFullyInViewport","wasAboveViewport","wasBelowViewport","isInViewport","isFullyInViewport","isAboveViewport","isBelowViewport","previousTop","previousBottom","nodeName","cachedDisplay","style","display","containerOffset","boundingRect","getBoundingClientRect","height","undefined","on","Error","join","off","one","recalculateSize","index","indexOf","lock","unlock","eventHandlerFactory","type"],"mappings":"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","file":"scrollMonitor.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"scrollMonitor\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"scrollMonitor\"] = factory();\n\telse\n\t\troot[\"scrollMonitor\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"scrollMonitor\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"scrollMonitor\"] = factory();\n\telse\n\t\troot[\"scrollMonitor\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _constants = __webpack_require__(1);\n\t\n\tvar _container = __webpack_require__(2);\n\t\n\tvar _container2 = _interopRequireDefault(_container);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar scrollMonitor = new _container2.default(_constants.isInBrowser ? document.body : null);\n\tscrollMonitor.setStateFromDOM(null);\n\tscrollMonitor.listenToDOM();\n\t\n\tif (_constants.isInBrowser) {\n\t\twindow.scrollMonitor = scrollMonitor;\n\t}\n\t\n\tmodule.exports = scrollMonitor;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\tvar VISIBILITYCHANGE = exports.VISIBILITYCHANGE = 'visibilityChange';\n\tvar ENTERVIEWPORT = exports.ENTERVIEWPORT = 'enterViewport';\n\tvar FULLYENTERVIEWPORT = exports.FULLYENTERVIEWPORT = 'fullyEnterViewport';\n\tvar EXITVIEWPORT = exports.EXITVIEWPORT = 'exitViewport';\n\tvar PARTIALLYEXITVIEWPORT = exports.PARTIALLYEXITVIEWPORT = 'partiallyExitViewport';\n\tvar LOCATIONCHANGE = exports.LOCATIONCHANGE = 'locationChange';\n\tvar STATECHANGE = exports.STATECHANGE = 'stateChange';\n\t\n\tvar eventTypes = exports.eventTypes = [VISIBILITYCHANGE, ENTERVIEWPORT, FULLYENTERVIEWPORT, EXITVIEWPORT, PARTIALLYEXITVIEWPORT, LOCATIONCHANGE, STATECHANGE];\n\t\n\tvar isOnServer = exports.isOnServer = typeof window === 'undefined';\n\tvar isInBrowser = exports.isInBrowser = !isOnServer;\n\t\n\tvar defaultOffsets = exports.defaultOffsets = { top: 0, bottom: 0 };\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _constants = __webpack_require__(1);\n\t\n\tvar _watcher = __webpack_require__(3);\n\t\n\tvar _watcher2 = _interopRequireDefault(_watcher);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction getViewportHeight(element) {\n\t\tif (_constants.isOnServer) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (element === document.body) {\n\t\t\treturn window.innerHeight || document.documentElement.clientHeight;\n\t\t} else {\n\t\t\treturn element.clientHeight;\n\t\t}\n\t}\n\t\n\tfunction getContentHeight(element) {\n\t\tif (_constants.isOnServer) {\n\t\t\treturn 0;\n\t\t}\n\t\n\t\tif (element === document.body) {\n\t\t\t// jQuery approach\n\t\t\t// whichever is greatest\n\t\t\treturn Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.documentElement.clientHeight);\n\t\t} else {\n\t\t\treturn element.scrollHeight;\n\t\t}\n\t}\n\t\n\tfunction scrollTop(element) {\n\t\tif (_constants.isOnServer) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (element === document.body) {\n\t\t\treturn window.pageYOffset || document.documentElement && document.documentElement.scrollTop || document.body.scrollTop;\n\t\t} else {\n\t\t\treturn element.scrollTop;\n\t\t}\n\t}\n\t\n\tvar ScrollMonitorContainer = function () {\n\t\tfunction ScrollMonitorContainer(item, parentWatcher) {\n\t\t\t_classCallCheck(this, ScrollMonitorContainer);\n\t\n\t\t\tvar self = this;\n\t\n\t\t\tthis.item = item;\n\t\t\tthis.watchers = [];\n\t\t\tthis.viewportTop = null;\n\t\t\tthis.viewportBottom = null;\n\t\t\tthis.documentHeight = getContentHeight(item);\n\t\t\tthis.viewportHeight = getViewportHeight(item);\n\t\t\tthis.DOMListener = this.DOMListener.bind(this);\n\t\n\t\t\tif (parentWatcher) {\n\t\t\t\tthis.containerWatcher = parentWatcher.create(item);\n\t\t\t}\n\t\n\t\t\tvar previousDocumentHeight;\n\t\n\t\t\tvar calculateViewportI;\n\t\t\tfunction calculateViewport() {\n\t\t\t\tself.viewportTop = scrollTop(item);\n\t\t\t\tself.viewportBottom = self.viewportTop + self.viewportHeight;\n\t\t\t\tself.documentHeight = getContentHeight(item);\n\t\t\t\tif (self.documentHeight !== previousDocumentHeight) {\n\t\t\t\t\tcalculateViewportI = self.watchers.length;\n\t\t\t\t\twhile (calculateViewportI--) {\n\t\t\t\t\t\tself.watchers[calculateViewportI].recalculateLocation();\n\t\t\t\t\t}\n\t\t\t\t\tpreviousDocumentHeight = self.documentHeight;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tvar updateAndTriggerWatchersI;\n\t\t\tfunction updateAndTriggerWatchers() {\n\t\t\t\t// update all watchers then trigger the events so one can rely on another being up to date.\n\t\t\t\tupdateAndTriggerWatchersI = self.watchers.length;\n\t\t\t\twhile (updateAndTriggerWatchersI--) {\n\t\t\t\t\tself.watchers[updateAndTriggerWatchersI].update();\n\t\t\t\t}\n\t\n\t\t\t\tupdateAndTriggerWatchersI = self.watchers.length;\n\t\t\t\twhile (updateAndTriggerWatchersI--) {\n\t\t\t\t\tself.watchers[updateAndTriggerWatchersI].triggerCallbacks();\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tthis.update = function () {\n\t\t\t\tcalculateViewport();\n\t\t\t\tupdateAndTriggerWatchers();\n\t\t\t};\n\t\t\tthis.recalculateLocations = function () {\n\t\t\t\tthis.documentHeight = 0;\n\t\t\t\tthis.update();\n\t\t\t};\n\t\t}\n\t\n\t\t_createClass(ScrollMonitorContainer, [{\n\t\t\tkey: 'listenToDOM',\n\t\t\tvalue: function listenToDOM() {\n\t\t\t\tif (_constants.isInBrowser) {\n\t\t\t\t\tif (window.addEventListener) {\n\t\t\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\t\t\twindow.addEventListener('scroll', this.DOMListener);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.item.addEventListener('scroll', this.DOMListener);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twindow.addEventListener('resize', this.DOMListener);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Old IE support\n\t\t\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\t\t\twindow.attachEvent('onscroll', this.DOMListener);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.item.attachEvent('onscroll', this.DOMListener);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twindow.attachEvent('onresize', this.DOMListener);\n\t\t\t\t\t}\n\t\t\t\t\tthis.destroy = function () {\n\t\t\t\t\t\tif (window.addEventListener) {\n\t\t\t\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\t\t\t\twindow.removeEventListener('scroll', this.DOMListener);\n\t\t\t\t\t\t\t\tthis.containerWatcher.destroy();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.item.removeEventListener('scroll', this.DOMListener);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twindow.removeEventListener('resize', this.DOMListener);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Old IE support\n\t\t\t\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\t\t\t\twindow.detachEvent('onscroll', this.DOMListener);\n\t\t\t\t\t\t\t\tthis.containerWatcher.destroy();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.item.detachEvent('onscroll', this.DOMListener);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twindow.detachEvent('onresize', this.DOMListener);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'destroy',\n\t\t\tvalue: function destroy() {\n\t\t\t\t// noop, override for your own purposes.\n\t\t\t\t// in listenToDOM, for example.\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'DOMListener',\n\t\t\tvalue: function DOMListener(event) {\n\t\t\t\tthis.setStateFromDOM(event);\n\t\t\t\tthis.updateAndTriggerWatchers(event);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'setStateFromDOM',\n\t\t\tvalue: function setStateFromDOM(event) {\n\t\t\t\tvar viewportTop = scrollTop(this.item);\n\t\t\t\tvar viewportHeight = getViewportHeight(this.item);\n\t\t\t\tvar contentHeight = getContentHeight(this.item);\n\t\n\t\t\t\tthis.setState(viewportTop, viewportHeight, contentHeight, event);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'setState',\n\t\t\tvalue: function setState(newViewportTop, newViewportHeight, newContentHeight, event) {\n\t\t\t\tvar needsRecalcuate = newViewportHeight !== this.viewportHeight || newContentHeight !== this.contentHeight;\n\t\n\t\t\t\tthis.latestEvent = event;\n\t\t\t\tthis.viewportTop = newViewportTop;\n\t\t\t\tthis.viewportHeight = newViewportHeight;\n\t\t\t\tthis.viewportBottom = newViewportTop + newViewportHeight;\n\t\t\t\tthis.contentHeight = newContentHeight;\n\t\n\t\t\t\tif (needsRecalcuate) {\n\t\t\t\t\tvar i = this.watchers.length;\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tthis.watchers[i].recalculateLocation();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.updateAndTriggerWatchers(event);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'updateAndTriggerWatchers',\n\t\t\tvalue: function updateAndTriggerWatchers(event) {\n\t\t\t\tvar i = this.watchers.length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tthis.watchers[i].update();\n\t\t\t\t}\n\t\n\t\t\t\ti = this.watchers.length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tthis.watchers[i].triggerCallbacks(event);\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'createCustomContainer',\n\t\t\tvalue: function createCustomContainer() {\n\t\t\t\treturn new ScrollMonitorContainer();\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'createContainer',\n\t\t\tvalue: function createContainer(item) {\n\t\t\t\tif (typeof item === 'string') {\n\t\t\t\t\titem = document.querySelector(item);\n\t\t\t\t} else if (item && item.length > 0) {\n\t\t\t\t\titem = item[0];\n\t\t\t\t}\n\t\t\t\tvar container = new ScrollMonitorContainer(item, this);\n\t\t\t\tcontainer.setStateFromDOM();\n\t\t\t\tcontainer.listenToDOM();\n\t\t\t\treturn container;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'create',\n\t\t\tvalue: function create(item, offsets) {\n\t\t\t\tif (typeof item === 'string') {\n\t\t\t\t\titem = document.querySelector(item);\n\t\t\t\t} else if (item && item.length > 0) {\n\t\t\t\t\titem = item[0];\n\t\t\t\t}\n\t\t\t\tvar watcher = new _watcher2.default(this, item, offsets);\n\t\t\t\tthis.watchers.push(watcher);\n\t\t\t\treturn watcher;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'beget',\n\t\t\tvalue: function beget(item, offsets) {\n\t\t\t\treturn this.create(item, offsets);\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn ScrollMonitorContainer;\n\t}();\n\t\n\texports.default = ScrollMonitorContainer;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\texports.default = ElementWatcher;\n\t\n\tvar _constants = __webpack_require__(1);\n\t\n\tfunction ElementWatcher(containerWatcher, watchItem, offsets) {\n\t\tvar self = this;\n\t\n\t\tthis.watchItem = watchItem;\n\t\tthis.container = containerWatcher;\n\t\n\t\tif (!offsets) {\n\t\t\tthis.offsets = _constants.defaultOffsets;\n\t\t} else if (offsets === +offsets) {\n\t\t\tthis.offsets = { top: offsets, bottom: offsets };\n\t\t} else {\n\t\t\tthis.offsets = {\n\t\t\t\ttop: offsets.top || _constants.defaultOffsets.top,\n\t\t\t\tbottom: offsets.bottom || _constants.defaultOffsets.bottom\n\t\t\t};\n\t\t}\n\t\n\t\tthis.callbacks = {}; // {callback: function, isOne: true }\n\t\n\t\tfor (var i = 0, j = _constants.eventTypes.length; i < j; i++) {\n\t\t\tself.callbacks[_constants.eventTypes[i]] = [];\n\t\t}\n\t\n\t\tthis.locked = false;\n\t\n\t\tvar wasInViewport;\n\t\tvar wasFullyInViewport;\n\t\tvar wasAboveViewport;\n\t\tvar wasBelowViewport;\n\t\n\t\tvar listenerToTriggerListI;\n\t\tvar listener;\n\t\tfunction triggerCallbackArray(listeners, event) {\n\t\t\tif (listeners.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlistenerToTriggerListI = listeners.length;\n\t\t\twhile (listenerToTriggerListI--) {\n\t\t\t\tlistener = listeners[listenerToTriggerListI];\n\t\t\t\tlistener.callback.call(self, event, self);\n\t\t\t\tif (listener.isOne) {\n\t\t\t\t\tlisteners.splice(listenerToTriggerListI, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.triggerCallbacks = function triggerCallbacks(event) {\n\t\n\t\t\tif (this.isInViewport && !wasInViewport) {\n\t\t\t\ttriggerCallbackArray(this.callbacks[_constants.ENTERVIEWPORT], event);\n\t\t\t}\n\t\t\tif (this.isFullyInViewport && !wasFullyInViewport) {\n\t\t\t\ttriggerCallbackArray(this.callbacks[_constants.FULLYENTERVIEWPORT], event);\n\t\t\t}\n\t\n\t\t\tif (this.isAboveViewport !== wasAboveViewport && this.isBelowViewport !== wasBelowViewport) {\n\t\n\t\t\t\ttriggerCallbackArray(this.callbacks[_constants.VISIBILITYCHANGE], event);\n\t\n\t\t\t\t// if you skip completely past this element\n\t\t\t\tif (!wasFullyInViewport && !this.isFullyInViewport) {\n\t\t\t\t\ttriggerCallbackArray(this.callbacks[_constants.FULLYENTERVIEWPORT], event);\n\t\t\t\t\ttriggerCallbackArray(this.callbacks[_constants.PARTIALLYEXITVIEWPORT], event);\n\t\t\t\t}\n\t\t\t\tif (!wasInViewport && !this.isInViewport) {\n\t\t\t\t\ttriggerCallbackArray(this.callbacks[_constants.ENTERVIEWPORT], event);\n\t\t\t\t\ttriggerCallbackArray(this.callbacks[_constants.EXITVIEWPORT], event);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (!this.isFullyInViewport && wasFullyInViewport) {\n\t\t\t\ttriggerCallbackArray(this.callbacks[_constants.PARTIALLYEXITVIEWPORT], event);\n\t\t\t}\n\t\t\tif (!this.isInViewport && wasInViewport) {\n\t\t\t\ttriggerCallbackArray(this.callbacks[_constants.EXITVIEWPORT], event);\n\t\t\t}\n\t\t\tif (this.isInViewport !== wasInViewport) {\n\t\t\t\ttriggerCallbackArray(this.callbacks[_constants.VISIBILITYCHANGE], event);\n\t\t\t}\n\t\t\tswitch (true) {\n\t\t\t\tcase wasInViewport !== this.isInViewport:\n\t\t\t\tcase wasFullyInViewport !== this.isFullyInViewport:\n\t\t\t\tcase wasAboveViewport !== this.isAboveViewport:\n\t\t\t\tcase wasBelowViewport !== this.isBelowViewport:\n\t\t\t\t\ttriggerCallbackArray(this.callbacks[_constants.STATECHANGE], event);\n\t\t\t}\n\t\n\t\t\twasInViewport = this.isInViewport;\n\t\t\twasFullyInViewport = this.isFullyInViewport;\n\t\t\twasAboveViewport = this.isAboveViewport;\n\t\t\twasBelowViewport = this.isBelowViewport;\n\t\t};\n\t\n\t\tthis.recalculateLocation = function () {\n\t\t\tif (this.locked) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar previousTop = this.top;\n\t\t\tvar previousBottom = this.bottom;\n\t\t\tif (this.watchItem.nodeName) {\n\t\t\t\t// a dom element\n\t\t\t\tvar cachedDisplay = this.watchItem.style.display;\n\t\t\t\tif (cachedDisplay === 'none') {\n\t\t\t\t\tthis.watchItem.style.display = '';\n\t\t\t\t}\n\t\n\t\t\t\tvar containerOffset = 0;\n\t\t\t\tvar container = this.container;\n\t\t\t\twhile (container.containerWatcher) {\n\t\t\t\t\tcontainerOffset += container.containerWatcher.top - container.containerWatcher.container.viewportTop;\n\t\t\t\t\tcontainer = container.containerWatcher.container;\n\t\t\t\t}\n\t\n\t\t\t\tvar boundingRect = this.watchItem.getBoundingClientRect();\n\t\t\t\tthis.top = boundingRect.top + this.container.viewportTop - containerOffset;\n\t\t\t\tthis.bottom = boundingRect.bottom + this.container.viewportTop - containerOffset;\n\t\n\t\t\t\tif (cachedDisplay === 'none') {\n\t\t\t\t\tthis.watchItem.style.display = cachedDisplay;\n\t\t\t\t}\n\t\t\t} else if (this.watchItem === +this.watchItem) {\n\t\t\t\t// number\n\t\t\t\tif (this.watchItem > 0) {\n\t\t\t\t\tthis.top = this.bottom = this.watchItem;\n\t\t\t\t} else {\n\t\t\t\t\tthis.top = this.bottom = this.container.documentHeight - this.watchItem;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// an object with a top and bottom property\n\t\t\t\tthis.top = this.watchItem.top;\n\t\t\t\tthis.bottom = this.watchItem.bottom;\n\t\t\t}\n\t\n\t\t\tthis.top -= this.offsets.top;\n\t\t\tthis.bottom += this.offsets.bottom;\n\t\t\tthis.height = this.bottom - this.top;\n\t\n\t\t\tif ((previousTop !== undefined || previousBottom !== undefined) && (this.top !== previousTop || this.bottom !== previousBottom)) {\n\t\t\t\ttriggerCallbackArray(this.callbacks[_constants.LOCATIONCHANGE], null);\n\t\t\t}\n\t\t};\n\t\n\t\tthis.recalculateLocation();\n\t\tthis.update();\n\t\n\t\twasInViewport = this.isInViewport;\n\t\twasFullyInViewport = this.isFullyInViewport;\n\t\twasAboveViewport = this.isAboveViewport;\n\t\twasBelowViewport = this.isBelowViewport;\n\t}\n\t\n\tElementWatcher.prototype = {\n\t\ton: function on(event, callback, isOne) {\n\t\n\t\t\t// trigger the event if it applies to the element right now.\n\t\t\tswitch (true) {\n\t\t\t\tcase event === _constants.VISIBILITYCHANGE && !this.isInViewport && this.isAboveViewport:\n\t\t\t\tcase event === _constants.ENTERVIEWPORT && this.isInViewport:\n\t\t\t\tcase event === _constants.FULLYENTERVIEWPORT && this.isFullyInViewport:\n\t\t\t\tcase event === _constants.EXITVIEWPORT && this.isAboveViewport && !this.isInViewport:\n\t\t\t\tcase event === _constants.PARTIALLYEXITVIEWPORT && this.isAboveViewport:\n\t\t\t\t\tcallback.call(this, this.container.latestEvent, this);\n\t\t\t\t\tif (isOne) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (this.callbacks[event]) {\n\t\t\t\tthis.callbacks[event].push({ callback: callback, isOne: isOne || false });\n\t\t\t} else {\n\t\t\t\tthrow new Error('Tried to add a scroll monitor listener of type ' + event + '. Your options are: ' + _constants.eventTypes.join(', '));\n\t\t\t}\n\t\t},\n\t\toff: function off(event, callback) {\n\t\t\tif (this.callbacks[event]) {\n\t\t\t\tfor (var i = 0, item; item = this.callbacks[event][i]; i++) {\n\t\t\t\t\tif (item.callback === callback) {\n\t\t\t\t\t\tthis.callbacks[event].splice(i, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error('Tried to remove a scroll monitor listener of type ' + event + '. Your options are: ' + _constants.eventTypes.join(', '));\n\t\t\t}\n\t\t},\n\t\tone: function one(event, callback) {\n\t\t\tthis.on(event, callback, true);\n\t\t},\n\t\trecalculateSize: function recalculateSize() {\n\t\t\tthis.height = this.watchItem.offsetHeight + this.offsets.top + this.offsets.bottom;\n\t\t\tthis.bottom = this.top + this.height;\n\t\t},\n\t\tupdate: function update() {\n\t\t\tthis.isAboveViewport = this.top < this.container.viewportTop;\n\t\t\tthis.isBelowViewport = this.bottom > this.container.viewportBottom;\n\t\n\t\t\tthis.isInViewport = this.top < this.container.viewportBottom && this.bottom > this.container.viewportTop;\n\t\t\tthis.isFullyInViewport = this.top >= this.container.viewportTop && this.bottom <= this.container.viewportBottom || this.isAboveViewport && this.isBelowViewport;\n\t\t},\n\t\tdestroy: function destroy() {\n\t\t\tvar index = this.container.watchers.indexOf(this),\n\t\t\t    self = this;\n\t\t\tthis.container.watchers.splice(index, 1);\n\t\t\tfor (var i = 0, j = _constants.eventTypes.length; i < j; i++) {\n\t\t\t\tself.callbacks[_constants.eventTypes[i]].length = 0;\n\t\t\t}\n\t\t},\n\t\t// prevent recalculating the element location\n\t\tlock: function lock() {\n\t\t\tthis.locked = true;\n\t\t},\n\t\tunlock: function unlock() {\n\t\t\tthis.locked = false;\n\t\t}\n\t};\n\t\n\tvar eventHandlerFactory = function eventHandlerFactory(type) {\n\t\treturn function (callback, isOne) {\n\t\t\tthis.on.call(this, type, callback, isOne);\n\t\t};\n\t};\n\t\n\tfor (var i = 0, j = _constants.eventTypes.length; i < j; i++) {\n\t\tvar type = _constants.eventTypes[i];\n\t\tElementWatcher.prototype[type] = eventHandlerFactory(type);\n\t}\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// scrollMonitor.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap f4ddac080de9d0b47b84","import { isInBrowser } from './src/constants';\n\nimport ScrollMonitorContainer from './src/container';\n\nvar scrollMonitor = new ScrollMonitorContainer(isInBrowser ? document.body : null);\nscrollMonitor.setStateFromDOM(null);\nscrollMonitor.listenToDOM();\n\nif (isInBrowser) {\n\twindow.scrollMonitor = scrollMonitor;\n}\n\nmodule.exports = scrollMonitor;\n\n\n\n// WEBPACK FOOTER //\n// ./index.js","export const VISIBILITYCHANGE = 'visibilityChange';\nexport const ENTERVIEWPORT = 'enterViewport';\nexport const FULLYENTERVIEWPORT = 'fullyEnterViewport';\nexport const EXITVIEWPORT = 'exitViewport';\nexport const PARTIALLYEXITVIEWPORT = 'partiallyExitViewport';\nexport const LOCATIONCHANGE = 'locationChange';\nexport const STATECHANGE = 'stateChange';\n\nexport const eventTypes = [\n\tVISIBILITYCHANGE,\n\tENTERVIEWPORT,\n\tFULLYENTERVIEWPORT,\n\tEXITVIEWPORT,\n\tPARTIALLYEXITVIEWPORT,\n\tLOCATIONCHANGE,\n\tSTATECHANGE\n];\n\nexport const isOnServer = (typeof window === 'undefined');\nexport const isInBrowser = !isOnServer;\n\nexport const defaultOffsets = {top: 0, bottom: 0};\n\n\n\n// WEBPACK FOOTER //\n// ./src/constants.js","import { isOnServer, isInBrowser } from './constants';\nimport Watcher from './watcher';\n\nfunction getViewportHeight (element) {\n\tif (isOnServer) {\n\t\treturn 0;\n\t}\n\tif (element === document.body) {\n\t\treturn window.innerHeight || document.documentElement.clientHeight;\n\t} else {\n\t\treturn element.clientHeight;\n\t}\n}\n\nfunction getContentHeight (element) {\n\tif (isOnServer) {\n\t\treturn 0;\n\t}\n\n\tif (element === document.body) {\n\t\t// jQuery approach\n\t\t// whichever is greatest\n\t\treturn Math.max(\n\t\t\tdocument.body.scrollHeight, document.documentElement.scrollHeight,\n\t\t\tdocument.body.offsetHeight, document.documentElement.offsetHeight,\n\t\t\tdocument.documentElement.clientHeight\n\t\t);\n\t} else {\n\t\treturn element.scrollHeight;\n\t}\n}\n\nfunction scrollTop (element) {\n\tif (isOnServer) {\n\t\treturn 0;\n\t}\n\tif (element === document.body) {\n\t\treturn window.pageYOffset ||\n\t\t\t(document.documentElement && document.documentElement.scrollTop) ||\n\t\t\tdocument.body.scrollTop;\n\t} else {\n\t\treturn element.scrollTop;\n\t}\n}\n\n\nclass ScrollMonitorContainer {\n\tconstructor (item, parentWatcher) {\n\t\tvar self = this;\n\n\t\tthis.item = item;\n\t\tthis.watchers = [];\n\t\tthis.viewportTop = null;\n\t\tthis.viewportBottom = null;\n\t\tthis.documentHeight = getContentHeight(item);\n\t\tthis.viewportHeight = getViewportHeight(item);\n\t\tthis.DOMListener = this.DOMListener.bind(this);\n\n\t\tif (parentWatcher) {\n\t\t\tthis.containerWatcher = parentWatcher.create(item);\n\t\t}\n\n\t\tvar previousDocumentHeight;\n\n\t\tvar calculateViewportI;\n\t\tfunction calculateViewport() {\n\t\t\tself.viewportTop = scrollTop(item);\n\t\t\tself.viewportBottom = self.viewportTop + self.viewportHeight;\n\t\t\tself.documentHeight = getContentHeight(item);\n\t\t\tif (self.documentHeight !== previousDocumentHeight) {\n\t\t\t\tcalculateViewportI = self.watchers.length;\n\t\t\t\twhile( calculateViewportI-- ) {\n\t\t\t\t\tself.watchers[calculateViewportI].recalculateLocation();\n\t\t\t\t}\n\t\t\t\tpreviousDocumentHeight = self.documentHeight;\n\t\t\t}\n\t\t}\n\n\t\tvar updateAndTriggerWatchersI;\n\t\tfunction updateAndTriggerWatchers() {\n\t\t\t// update all watchers then trigger the events so one can rely on another being up to date.\n\t\t\tupdateAndTriggerWatchersI = self.watchers.length;\n\t\t\twhile( updateAndTriggerWatchersI-- ) {\n\t\t\t\tself.watchers[updateAndTriggerWatchersI].update();\n\t\t\t}\n\n\t\t\tupdateAndTriggerWatchersI = self.watchers.length;\n\t\t\twhile( updateAndTriggerWatchersI-- ) {\n\t\t\t\tself.watchers[updateAndTriggerWatchersI].triggerCallbacks();\n\t\t\t}\n\n\t\t}\n\n\t\tthis.update = function() {\n\t\t\tcalculateViewport();\n\t\t\tupdateAndTriggerWatchers();\n\t\t};\n\t\tthis.recalculateLocations = function() {\n\t\t\tthis.documentHeight = 0;\n\t\t\tthis.update();\n\t\t};\n\n\t}\n\n\tlistenToDOM () {\n\t\tif (isInBrowser) {\n\t\t\tif (window.addEventListener) {\n\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\twindow.addEventListener('scroll', this.DOMListener);\n\t\t\t\t} else {\n\t\t\t\t\tthis.item.addEventListener('scroll', this.DOMListener);\n\t\t\t\t}\n\t\t\t\twindow.addEventListener('resize', this.DOMListener);\n\t\t\t} else {\n\t\t\t\t// Old IE support\n\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\twindow.attachEvent('onscroll', this.DOMListener);\n\t\t\t\t} else {\n\t\t\t\t\tthis.item.attachEvent('onscroll', this.DOMListener);\n\t\t\t\t}\n\t\t\t\twindow.attachEvent('onresize', this.DOMListener);\n\t\t\t}\n\t\t\tthis.destroy = function () {\n\t\t\t\tif (window.addEventListener) {\n\t\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\t\twindow.removeEventListener('scroll', this.DOMListener);\n\t\t\t\t\t\tthis.containerWatcher.destroy();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.item.removeEventListener('scroll', this.DOMListener);\n\t\t\t\t\t}\n\t\t\t\t\twindow.removeEventListener('resize', this.DOMListener);\n\t\t\t\t} else {\n\t\t\t\t\t// Old IE support\n\t\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\t\twindow.detachEvent('onscroll', this.DOMListener);\n\t\t\t\t\t\tthis.containerWatcher.destroy();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.item.detachEvent('onscroll', this.DOMListener);\n\t\t\t\t\t}\n\t\t\t\t\twindow.detachEvent('onresize', this.DOMListener);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\tdestroy () {\n\t\t// noop, override for your own purposes.\n\t\t// in listenToDOM, for example.\n\t}\n\n\tDOMListener (event) {\n\t\tthis.setStateFromDOM(event);\n\t\tthis.updateAndTriggerWatchers(event);\n\t}\n\n\tsetStateFromDOM (event) {\n\t\tvar viewportTop = scrollTop(this.item);\n\t\tvar viewportHeight = getViewportHeight(this.item);\n\t\tvar contentHeight = getContentHeight(this.item);\n\n\t\tthis.setState(viewportTop, viewportHeight, contentHeight, event);\n\t}\n\n\tsetState (newViewportTop, newViewportHeight, newContentHeight, event) {\n\t\tvar needsRecalcuate = (newViewportHeight !== this.viewportHeight || newContentHeight !== this.contentHeight);\n\n\t\tthis.latestEvent = event;\n\t\tthis.viewportTop = newViewportTop;\n\t\tthis.viewportHeight = newViewportHeight;\n\t\tthis.viewportBottom = newViewportTop + newViewportHeight;\n\t\tthis.contentHeight = newContentHeight;\n\n\t\tif (needsRecalcuate) {\n\t\t\tlet i = this.watchers.length;\n\t\t\twhile (i--) {\n\t\t\t\tthis.watchers[i].recalculateLocation();\n\t\t\t}\n\t\t}\n\t\tthis.updateAndTriggerWatchers(event);\n\t}\n\n\tupdateAndTriggerWatchers (event) {\n\t\tlet i = this.watchers.length;\n\t\twhile (i--) {\n\t\t\tthis.watchers[i].update();\n\t\t}\n\n\t\ti = this.watchers.length;\n\t\twhile (i--) {\n\t\t\tthis.watchers[i].triggerCallbacks(event);\n\t\t}\n\t}\n\n\tcreateCustomContainer () {\n\t\treturn new ScrollMonitorContainer();\n\t}\n\n\tcreateContainer (item) {\n\t\tif (typeof item === 'string') {\n\t\t\titem = document.querySelector(item);\n\t\t} else if (item && item.length > 0) {\n\t\t\titem = item[0];\n\t\t}\n\t\tvar container = new ScrollMonitorContainer(item, this);\n\t\tcontainer.setStateFromDOM();\n\t\tcontainer.listenToDOM();\n\t\treturn container;\n\t}\n\n\tcreate (item, offsets) {\n\t\tif (typeof item === 'string') {\n\t\t\titem = document.querySelector(item);\n\t\t} else if (item && item.length > 0) {\n\t\t\titem = item[0];\n\t\t}\n\t\tvar watcher = new Watcher(this, item, offsets);\n\t\tthis.watchers.push(watcher);\n\t\treturn watcher;\n\t}\n\n\tbeget (item, offsets) {\n\t\treturn this.create(item, offsets);\n\t}\n}\n\nexport default ScrollMonitorContainer;\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/container.js","import {\n\tVISIBILITYCHANGE,\n\tENTERVIEWPORT,\n\tFULLYENTERVIEWPORT,\n\tEXITVIEWPORT,\n\tPARTIALLYEXITVIEWPORT,\n\tLOCATIONCHANGE,\n\tSTATECHANGE,\n\teventTypes,\n\tdefaultOffsets\n} from './constants';\n\nexport default function ElementWatcher (containerWatcher, watchItem, offsets) {\n\tvar self = this;\n\n\tthis.watchItem = watchItem;\n\tthis.container = containerWatcher;\n\n\tif (!offsets) {\n\t\tthis.offsets = defaultOffsets;\n\t} else if (offsets === +offsets) {\n\t\tthis.offsets = {top: offsets, bottom: offsets};\n\t} else {\n\t\tthis.offsets = {\n\t\t\ttop: offsets.top || defaultOffsets.top,\n\t\t\tbottom: offsets.bottom || defaultOffsets.bottom\n\t\t};\n\t}\n\n\tthis.callbacks = {}; // {callback: function, isOne: true }\n\n\tfor (var i = 0, j = eventTypes.length; i < j; i++) {\n\t\tself.callbacks[eventTypes[i]] = [];\n\t}\n\n\tthis.locked = false;\n\n\tvar wasInViewport;\n\tvar wasFullyInViewport;\n\tvar wasAboveViewport;\n\tvar wasBelowViewport;\n\n\tvar listenerToTriggerListI;\n\tvar listener;\n\tfunction triggerCallbackArray (listeners, event) {\n\t\tif (listeners.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tlistenerToTriggerListI = listeners.length;\n\t\twhile (listenerToTriggerListI--) {\n\t\t\tlistener = listeners[listenerToTriggerListI];\n\t\t\tlistener.callback.call(self, event, self);\n\t\t\tif (listener.isOne) {\n\t\t\t\tlisteners.splice(listenerToTriggerListI, 1);\n\t\t\t}\n\t\t}\n\t}\n\tthis.triggerCallbacks = function triggerCallbacks (event) {\n\n\t\tif (this.isInViewport && !wasInViewport) {\n\t\t\ttriggerCallbackArray( this.callbacks[ENTERVIEWPORT], event );\n\t\t}\n\t\tif (this.isFullyInViewport && !wasFullyInViewport) {\n\t\t\ttriggerCallbackArray( this.callbacks[FULLYENTERVIEWPORT], event );\n\t\t}\n\n\n\t\tif (this.isAboveViewport !== wasAboveViewport &&\n\t\t\tthis.isBelowViewport !== wasBelowViewport) {\n\n\t\t\ttriggerCallbackArray( this.callbacks[VISIBILITYCHANGE], event );\n\n\t\t\t// if you skip completely past this element\n\t\t\tif (!wasFullyInViewport && !this.isFullyInViewport) {\n\t\t\t\ttriggerCallbackArray( this.callbacks[FULLYENTERVIEWPORT], event );\n\t\t\t\ttriggerCallbackArray( this.callbacks[PARTIALLYEXITVIEWPORT], event );\n\t\t\t}\n\t\t\tif (!wasInViewport && !this.isInViewport) {\n\t\t\t\ttriggerCallbackArray( this.callbacks[ENTERVIEWPORT], event );\n\t\t\t\ttriggerCallbackArray( this.callbacks[EXITVIEWPORT], event );\n\t\t\t}\n\t\t}\n\n\t\tif (!this.isFullyInViewport && wasFullyInViewport) {\n\t\t\ttriggerCallbackArray( this.callbacks[PARTIALLYEXITVIEWPORT], event );\n\t\t}\n\t\tif (!this.isInViewport && wasInViewport) {\n\t\t\ttriggerCallbackArray( this.callbacks[EXITVIEWPORT], event );\n\t\t}\n\t\tif (this.isInViewport !== wasInViewport) {\n\t\t\ttriggerCallbackArray( this.callbacks[VISIBILITYCHANGE], event );\n\t\t}\n\t\tswitch( true ) {\n\t\t\tcase wasInViewport !== this.isInViewport:\n\t\t\tcase wasFullyInViewport !== this.isFullyInViewport:\n\t\t\tcase wasAboveViewport !== this.isAboveViewport:\n\t\t\tcase wasBelowViewport !== this.isBelowViewport:\n\t\t\t\ttriggerCallbackArray( this.callbacks[STATECHANGE], event );\n\t\t}\n\n\t\twasInViewport = this.isInViewport;\n\t\twasFullyInViewport = this.isFullyInViewport;\n\t\twasAboveViewport = this.isAboveViewport;\n\t\twasBelowViewport = this.isBelowViewport;\n\n\t};\n\n\tthis.recalculateLocation = function () {\n\t\tif (this.locked) {\n\t\t\treturn;\n\t\t}\n\t\tvar previousTop = this.top;\n\t\tvar previousBottom = this.bottom;\n\t\tif (this.watchItem.nodeName) { // a dom element\n\t\t\tvar cachedDisplay = this.watchItem.style.display;\n\t\t\tif (cachedDisplay === 'none') {\n\t\t\t\tthis.watchItem.style.display = '';\n\t\t\t}\n\n\t\t\tvar containerOffset = 0;\n\t\t\tvar container = this.container;\n\t\t\twhile (container.containerWatcher) {\n\t\t\t\tcontainerOffset += container.containerWatcher.top - container.containerWatcher.container.viewportTop;\n\t\t\t\tcontainer = container.containerWatcher.container;\n\t\t\t}\n\n\t\t\tvar boundingRect = this.watchItem.getBoundingClientRect();\n\t\t\tthis.top = boundingRect.top + this.container.viewportTop - containerOffset;\n\t\t\tthis.bottom = boundingRect.bottom + this.container.viewportTop - containerOffset;\n\n\t\t\tif (cachedDisplay === 'none') {\n\t\t\t\tthis.watchItem.style.display = cachedDisplay;\n\t\t\t}\n\n\t\t} else if (this.watchItem === +this.watchItem) { // number\n\t\t\tif (this.watchItem > 0) {\n\t\t\t\tthis.top = this.bottom = this.watchItem;\n\t\t\t} else {\n\t\t\t\tthis.top = this.bottom = this.container.documentHeight - this.watchItem;\n\t\t\t}\n\n\t\t} else { // an object with a top and bottom property\n\t\t\tthis.top = this.watchItem.top;\n\t\t\tthis.bottom = this.watchItem.bottom;\n\t\t}\n\n\t\tthis.top -= this.offsets.top;\n\t\tthis.bottom += this.offsets.bottom;\n\t\tthis.height = this.bottom - this.top;\n\n\t\tif ( (previousTop !== undefined || previousBottom !== undefined) && (this.top !== previousTop || this.bottom !== previousBottom) ) {\n\t\t\ttriggerCallbackArray( this.callbacks[LOCATIONCHANGE], null );\n\t\t}\n\t};\n\n\tthis.recalculateLocation();\n\tthis.update();\n\n\twasInViewport = this.isInViewport;\n\twasFullyInViewport = this.isFullyInViewport;\n\twasAboveViewport = this.isAboveViewport;\n\twasBelowViewport = this.isBelowViewport;\n}\n\nElementWatcher.prototype = {\n\ton: function (event, callback, isOne) {\n\n\t\t// trigger the event if it applies to the element right now.\n\t\tswitch( true ) {\n\t\t\tcase event === VISIBILITYCHANGE && !this.isInViewport && this.isAboveViewport:\n\t\t\tcase event === ENTERVIEWPORT && this.isInViewport:\n\t\t\tcase event === FULLYENTERVIEWPORT && this.isFullyInViewport:\n\t\t\tcase event === EXITVIEWPORT && this.isAboveViewport && !this.isInViewport:\n\t\t\tcase event === PARTIALLYEXITVIEWPORT && this.isAboveViewport:\n\t\t\t\tcallback.call(this, this.container.latestEvent, this);\n\t\t\t\tif (isOne) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t}\n\n\t\tif (this.callbacks[event]) {\n\t\t\tthis.callbacks[event].push({callback: callback, isOne: isOne||false});\n\t\t} else {\n\t\t\tthrow new Error('Tried to add a scroll monitor listener of type '+event+'. Your options are: '+eventTypes.join(', '));\n\t\t}\n\t},\n\toff: function( event, callback ) {\n\t\tif (this.callbacks[event]) {\n\t\t\tfor (var i = 0, item; item = this.callbacks[event][i]; i++) {\n\t\t\t\tif (item.callback === callback) {\n\t\t\t\t\tthis.callbacks[event].splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error('Tried to remove a scroll monitor listener of type '+event+'. Your options are: '+eventTypes.join(', '));\n\t\t}\n\t},\n\tone: function( event, callback ) {\n\t\tthis.on( event, callback, true);\n\t},\n\trecalculateSize: function() {\n\t\tthis.height = this.watchItem.offsetHeight + this.offsets.top + this.offsets.bottom;\n\t\tthis.bottom = this.top + this.height;\n\t},\n\tupdate: function() {\n\t\tthis.isAboveViewport = this.top < this.container.viewportTop;\n\t\tthis.isBelowViewport = this.bottom > this.container.viewportBottom;\n\n\t\tthis.isInViewport = (this.top < this.container.viewportBottom && this.bottom > this.container.viewportTop);\n\t\tthis.isFullyInViewport = (this.top >= this.container.viewportTop && this.bottom <= this.container.viewportBottom) || (this.isAboveViewport && this.isBelowViewport);\n\n\t},\n\tdestroy: function() {\n\t\tvar index = this.container.watchers.indexOf(this),\n\t\t\tself  = this;\n\t\tthis.container.watchers.splice(index, 1);\n\t\tfor (var i = 0, j = eventTypes.length; i < j; i++) {\n\t\t\tself.callbacks[eventTypes[i]].length = 0;\n\t\t}\n\t},\n\t// prevent recalculating the element location\n\tlock: function() {\n\t\tthis.locked = true;\n\t},\n\tunlock: function() {\n\t\tthis.locked = false;\n\t}\n};\n\nvar eventHandlerFactory = function (type) {\n\treturn function( callback, isOne ) {\n\t\tthis.on.call(this, type, callback, isOne);\n\t};\n};\n\nfor (var i = 0, j = eventTypes.length; i < j; i++) {\n\tvar type =  eventTypes[i];\n\tElementWatcher.prototype[type] = eventHandlerFactory(type);\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/watcher.js"],"sourceRoot":""}